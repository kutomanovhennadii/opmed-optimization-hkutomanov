\## 3.2.9 - Exception Hierarchy (Errors)



\### Purpose

This section defines the unified exception hierarchy for the Opmed optimization system.  

All modules propagate structured exceptions derived from a common base class `OpmedError`.  

This ensures consistent error reporting, predictable exit codes, and uniform log formatting across all pipeline stages.



---



\### Exception Hierarchy

OpmedError

├── ConfigError

├── DataError

├── ModelError

├── SolveError

├── ValidationError

└── VisualizationError





All exception classes inherit from `OpmedError` and include the following standard fields:

\- `message: str` — human-readable error description  

\- `source: str` — name of the module/function that raised the exception  

\- `suggested\_action: str` — recommended remediation or diagnostic step  

\- `exit\_code: int` — numerical code used by the orchestrator for process termination  



---



\### Contracts



\*\*Preconditions\*\*

\- Each module must raise only exceptions derived from `OpmedError`.  

\- Each subclass defines a unique, fixed `exit\_code`.  



\*\*Postconditions\*\*

\- Every raised exception is logged in `solver.log` with timestamp, message, and exit\_code.  

\- The orchestrator (`run.py`) terminates gracefully using the mapped exit code.  

\- In addition to the log, summary information may be stored in `metrics.json`:





"error\_type": "DataError",

"error\_message": "Negative duration detected in surgeries.csv"





---



\### Exception Mapping Table



| Exception | Source Module | Example Message | Exit Code | Suggested Action |

|------------|----------------|-----------------|------------|------------------|

| \*\*ConfigError\*\* | DataLoader / run.py | "Invalid or missing key 'time\_unit' in config.yaml" | 10 | Check and fix YAML configuration. |

| \*\*DataError\*\* | DataLoader / Validator | "Negative duration detected in surgeries.csv" | 20 | Verify CSV input integrity. |

| \*\*ModelError\*\* | ModelBuilder | "Failed to create IntervalVar for surgery S014" | 30 | Inspect constraint logic and variable definitions. |

| \*\*SolveError\*\* | Optimizer | "Solver terminated abnormally (INTERNAL\_ERROR)" | 40 | Review solver logs and configuration. |

| \*\*ValidationError\*\* | Validator | "Buffer rule violated between S01 and S02" | 50 | Adjust buffer parameter or verify time consistency. |

| \*\*VisualizationError\*\* | Visualizer | "Unable to save solution\_plot.png" | 60 | Ensure output directory exists and has proper permissions. |



---



\### Log Format for Exceptions

Each error is logged to `solver.log` as a structured line with fixed fields:







\[timestamp] ERROR \[ExceptionName] source=<module> code=<exit\_code> message="<message>" action="<suggested\_action>"





\*\*Example:\*\*





\[2025-10-30 14:48:00] ERROR \[DataError] source=dataloader.load\_surgeries code=20 message="Negative duration detected in surgeries.csv" action="Verify start and end timestamps."





---



\### Propagation Rules

\- Exceptions are caught and logged by the orchestrator (`run.py`).  

\- Each error type maps to a deterministic exit code (see table above).  

\- Unhandled exceptions default to `exit\_code = 99` and are wrapped as `OpmedError("Unexpected failure")`.  

\- Validation and visualization errors do not terminate the pipeline; they are logged as warnings if recoverable.  



---



\### Integration

| Pipeline Stage | Possible Exceptions | Severity | Handled By |

|----------------|--------------------|-----------|-------------|

| DataLoader | ConfigError, DataError | Fatal | run.py |

| ModelBuilder | ModelError, ConfigError | Fatal | run.py |

| Optimizer | SolveError | Fatal | run.py |

| Validator | ValidationError, DataError | Recoverable | run.py |

| Visualizer | VisualizationError | Recoverable | run.py |

| Metrics \& Logger | IOError (wrapped into OpmedError) | Recoverable | run.py |



---



\### Summary

The Opmed exception hierarchy standardizes how all modules report and handle errors.  

Each error type has a dedicated exit code, consistent log format, and actionable message.  

This system guarantees predictable behavior in CI/CD automation, experiment tracking, and reproducible reruns.



