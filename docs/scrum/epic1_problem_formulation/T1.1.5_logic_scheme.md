\# üß© T1.1.5 ‚Äî Logical Interaction Scheme



\## 1. General Concept

The system solves the anesthesiologist and room allocation problem using a CP-SAT optimization model. The data flow is organized as a sequential chain of modules, covering the full lifecycle ‚Äî from loading input data and parameters to obtaining an optimized schedule and evaluating efficiency metrics. Alongside the main ‚Äúdata ‚Üí solution ‚Üí validation‚Äù loop, there is a parallel hyperparameter tuning loop that automates solver parameter exploration to achieve optimal results while maintaining reproducibility.



\## 2. Modules and Their Roles

1\. \*\*DataLoader\*\* ‚Äî Loads input files (`surgeries.csv` / `schedule.parquet`) and configuration (`config.yaml`); validates time consistency (`start < end`, positive duration); converts timestamps into an internal numerical format (e.g., hours since day start).  

2\. \*\*ModelBuilder (SolverCore)\*\* ‚Äî Constructs the CP-SAT model with interval variables for surgeries (`IntervalVar`), binary decision variables for assignments (`BoolVar`), and constraints (`NoOverlap`, buffer, shift boundaries). Defines the objective function (minimization of total cost) and passes the model to the solver.  

3\. \*\*Optimizer (CP-SAT Solver)\*\* ‚Äî Solves the model using specified hyperparameters (`search\_branching`, `num\_workers`, `max\_time\_in\_seconds`, etc.) and saves results and metrics (total cost, utilization, runtime).  

4\. \*\*Validator\*\* ‚Äî Ensures that all constraints are satisfied: no overlapping surgeries, correct inter-room buffers, shift durations within \[5, 12] hours, and utilization ‚â• 0.8. Generates a validation report in case of violations.  

5\. \*\*Visualizer\*\* ‚Äî Produces a schedule diagram (anesthesiologists on Y-axis, time on X-axis, color by room) and exports both `solution.csv` and `solution\_plot.png`.  

6\. \*\*Metrics \& Logger\*\* ‚Äî Records all metrics (`total\_cost`, `utilization`, `runtime`) and stores solver logs, random seeds, and hyperparameter configurations for reproducibility.  

7\. \*\*Hyperparameter Tuner (MLOps Loop)\*\* ‚Äî Manages solver hyperparameter experiments using \*\*Airflow\*\* for orchestration and \*\*MLflow\*\* for experiment tracking. Supports grid, stochastic, or Bayesian search and updates `best\_config.yaml` based on performance results.



\## 3. Data Flows (ASCII Representation)



\### Main Flow

+--------------------+

|  surgeries.csv     |

|  config.yaml       |

+--------------------+

&nbsp;         |

&nbsp;         v

+--------------------+

|    DataLoader      |

+--------------------+

&nbsp;         |

&nbsp;         v

+--------------------+

|   ModelBuilder     |

+--------------------+

&nbsp;         |

&nbsp;         v

+--------------------+

|     Optimizer      |

+--------------------+

&nbsp;         |

&nbsp;         v

+--------------------+

|     Validator      |

+--------------------+

&nbsp;         |

&nbsp;         v

+--------------------+

|     Visualizer     |

+--------------------+

&nbsp;         |

&nbsp;         v

+-------------------------------------------------------+

| solution.csv | metrics.json | solver.log              |

+-------------------------------------------------------+



\### Hyperparameter Tuning Loop

+-------------------+

|   config.yaml     |

+-------------------+

&nbsp;         |

&nbsp;         v

+-------------------+

| Hyperparameter    |

|      Tuner        |

+-------------------+

&nbsp;         |

&nbsp;         v

+-------------------+

|   Optimizer Run   |

+-------------------+

&nbsp;         |

&nbsp;         v

+-------------------+

|  Log Metrics to   |

|      MLflow       |

+-------------------+

&nbsp;         |

&nbsp;         v

+-------------------+

| Analyze Results   |

| Update best\_config|

+-------------------+

&nbsp;         |

&nbsp;         ‚îî‚îÄ‚îÄ‚îÄ> Repeat Cycle



\## 4. Purpose of the Scheme

This architecture ensures full reproducibility of optimization experiments, automatic validation of schedule correctness, modular separation between optimization logic and input/output components, and seamless integration into CI/CD and MLOps workflows for future deployment.



